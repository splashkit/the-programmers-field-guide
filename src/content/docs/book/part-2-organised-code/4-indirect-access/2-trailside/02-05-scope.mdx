---
title: Pointers and Scope
sidebar:
  label: " - Pointers and Scope"
---

import MySwiper from '../../../../../../components/react/myswiper.jsx'

import sliderDanglingPointer01 from './images/slider-scope-dangling-pointer/Slide1.png';
import sliderDanglingPointer02 from './images/slider-scope-dangling-pointer/Slide2.png';
import sliderDanglingPointer03 from './images/slider-scope-dangling-pointer/Slide3.png';
import sliderDanglingPointer04 from './images/slider-scope-dangling-pointer/Slide4.png';
import sliderDanglingPointer05 from './images/slider-scope-dangling-pointer/Slide5.png';
import sliderDanglingPointer06 from './images/slider-scope-dangling-pointer/Slide6.png';
import sliderDanglingPointer07 from './images/slider-scope-dangling-pointer/Slide7.png';
import sliderDanglingPointer08 from './images/slider-scope-dangling-pointer/Slide8.png';
import sliderDanglingPointer09 from './images/slider-scope-dangling-pointer/Slide9.png';
import sliderDanglingPointer10 from './images/slider-scope-dangling-pointer/Slide10.png';
import sliderDanglingPointer11 from './images/slider-scope-dangling-pointer/Slide11.png';
import sliderDanglingPointer12 from './images/slider-scope-dangling-pointer/Slide12.png';
import sliderDanglingPointer13 from './images/slider-scope-dangling-pointer/Slide13.png';
import sliderDanglingPointer14 from './images/slider-scope-dangling-pointer/Slide14.png';

export const sliderDanglingPointer = [
  {
    src: sliderDanglingPointer01.src,
    altText: "The program begins at main, and lines 4 and 5 declare two variables p and other which are created on the stack. Note that variables of type long and long*are capable of storing memory addresses, though only p is declared as a pointer variable here.",
    tipStart: 1,
    tips: [
      "The program begins at main, and lines 4 and 5 declare two variables <strong>p</strong> and <strong>other</strong> which are created on the stack",
      "Note that variables of type <strong>long</strong> and <strong>long*</strong> are capable of storing memory addresses, though only <strong>p</strong> is declared as a pointer variable here"
    ]
  },
  {
    src: sliderDanglingPointer02.src,
    altText: "At step 6a, the get_pointer() function is called",
    tipStart: 2,
    tips: [
      "At step 6a, the <strong>get_pointer()</strong> function is called"
    ]
  },
  {
    src: sliderDanglingPointer03.src,
    altText: "When the get_pointer() function runs, line 13 declares the value variable of type long, which is created on the stack and initialized with the value 10. Line 14 then declares the result variable of type long*, which is a pointer variable. result is initialized to contain the memory address of the value variable, and hence becomes a pointer to value",
    tipStart: 3,
    tips: [
      "When the <strong>get_pointer()</strong> function runs, line 13 declares the variable <strong>value</strong> of type <strong>long</strong>, which is created on the stack and initialized with the value 10",
      "Line 14 then declares the variable <strong>result</strong> of type <strong>long*</strong>(i.e a pointer variable)",
      "<strong>result</strong> is initialized to contain the memory address of the <strong>value</strong> variable, and hence becomes a pointer to <strong>value</strong>"
    ]
  },
  {
    src: sliderDanglingPointer04.src,
    altText: "Lines 15 and 16 print out the memory addresses of the value and result variables as strings to the terminal. This is indicated by the '&' prefixing the variable names in the print statements",
    tipStart: 4,
    tips: [
      "Lines 15 and 16 print out the <em>memory addresses</em> of the <strong>value</strong> and <strong>result</strong> variables as strings to the terminal",
      "This is indicated by the '<strong>&</strong>' prefixing the variable names in the print statements"
    ]
  },
  {
    src: sliderDanglingPointer05.src,
    altText: "Line 17 returns the value of result (which is an address that points to value) to the caller in main()",
    tipStart: 5,
    tips: [
      "Line 17 returns the value of <strong>result</strong> (which is an address that points to <strong>value</strong>) to the caller in main()"
    ]
  },
  {
    src: sliderDanglingPointer06.src,
    altText: "When the call to get_pointer() returns, the return value from the function ('result') is copied to the variable p<, which then becomes a pointer to the memory area on the stack that points to variable value that was scoped within the function (step 6b)",
    tipStart: 6,
    tips: [
      "When the call to <strong>get_pointer()</strong> returns, the return value from the function ('<strong>result</strong>') is copied to the variable <strong>p</strong>",
      "<strong>p</strong> then becomes a pointer to the memory area on the stack that points to variable <strong>value</strong> that was scoped within the function (step 6b)"
    ]
  },
  {
    src: sliderDanglingPointer07.src,
    altText: "Step 6c shows that once the function has returned and it's return value assigned to p, the function memory space on the stack is freed and available for other code to use. It so happens that data is left in place in these memory areas however (even though this data is no longer relevant with respect to the running program). In this case the pointer variable p has been left pointing to an area of memory that is not in use, but happens to contain the value '10'. We call this a dangling pointer",
    tipStart: 7,
    tips: [
      "Step 6c shows that once the function has returned and it's return value assigned to <strong>p</strong>, the function memory space on the stack is freed and available for other code to use",
      "It so happens that data is left in place in these memory areas however (even though this data is no longer relevant with respect to the running program)",
      "In this case the pointer variable <strong>p</strong> has been left pointing to an area of memory that is not in use, but happens to contain the value '10'",
      "We call this a <strong>dangling pointer</strong>"
    ]
  },
  {
    src: sliderDanglingPointer08.src,
    altText: "Line 7 prints the value of p which contains an address that points to the unallocated memory region left behind by the get_pointer() function that was called previously. Note that this time no '&' is required as a prefix to p in the print statement, since p already contains a memory address as it's value",
    tipStart: 8,
    tips: [
      "Line 7 prints the value of <strong>p</strong> which contains an address that points to the unallocated memory region left behind by the <strong>get_pointer()</strong> function that was called previously",
      "Note that this time no '<strong>&</strong>' is required as a prefix to <strong>p</strong> in the print statement, since <strong>p</strong> already contains a memory address as it's value"
    ]
  },
  {
    src: sliderDanglingPointer09.src,
    altText: "At line 8, step 8a calls another function get_value()",
    tipStart: 9,
    tips: [
      "At line 8, step 8a calls another function <strong>get_value()</strong>"
    ]
  },
  {
    src: sliderDanglingPointer10.src,
    altText: "The get_value() function runs, and lines 21 and 22, declare two local variables called result and other (of type long) on the stack, initializing them with values 20 and 30 respectively. Because the stack is a physical space, and acts like it's name suggests, it has allocated space for these two variables at the next free appropriate memory addresses available in the stack space. In this case since they are both of type long, they are allocated in the same physical memory space where the variables value and result existed from our previous call to get_pointer(), since this space was no longer being used. Hence they both override the stale data that was previously stored there, with their new values",
    tipStart: 10,
    tips: [
      "The <strong>get_value()</strong> function runs, and lines 21 and 22, declare two local variables called <strong>result</strong> and <strong>other</strong> (of type <strong>long</strong>) on the stack, initializing them with values 20 and 30 respectively",
      "Because the stack is a physical space, and acts like it's name suggests, it has allocated space for these two variables at the next free appropriate memory addresses available in the stack space",
      "In this case since they are both of type <strong>long</strong>, they are allocated in the <em>same</em> physical memory space where the variables <strong>value</strong> and <strong>result</strong> existed from our previous call to <strong>get_pointer()</strong>, since this space was no longer being used",
      "Hence they both override the <em>stale data</em> that was previously stored there, with their new values",
    ]
  },
  {
    src: sliderDanglingPointer11.src,
    altText: "Lines 23 and 24 print out the memory addresses of the result and other variables as strings to the terminal",
    tipStart: 11,
    tips: [
      "Lines 23 and 24 print out the memory addresses of the <strong>result</strong> and <strong>other</strong> variables as strings to the terminal"
    ]
  },
  {
    src: sliderDanglingPointer12.src,
    altText: "Line 25 returns the value of the calculation result + other to the caller in main()",
    tipStart: 12,
    tips: [
      "Line 25 returns the value of the calculation <strong>result + other</strong> to the caller in main()"
    ]
  },
  {
    src: sliderDanglingPointer13.src,
    altText: "At step 8b, the get_value() function has returned and it's return value assigned to other, then at step 8c the function memory space on the stack is freed and available for other code to use. Once again, it so happens that data is left in place in these unallocated memory areas however, even though this data is no longer relevant with respect to the running program. In this case the pointer variable p has been left pointing to an area of memory that is not in use, but happens to contain the value '20'",
    tipStart: 13,
    tips: [
      "At step 8b, the <strong>get_value()</strong> function has returned and it's return value assigned to <strong>other</strong>",
      "Then at step 8c the function memory space on the stack is freed and available for other code to use",
      "Once again, it so happens that data is left in place in these unallocated memory areas however, even though this data is no longer relevant with respect to the running program",
      "In this case the pointer variable <strong>p</strong> has been left pointing to an area of memory that is not in use, but happens to contain the value <strong>'20'</strong>",
    ]
  },
  {
    src: sliderDanglingPointer14.src,
    altText: "Finally at line 9, the program prints the dereferenced value of p which will contain the value '20' from the stale area of memory to which the dangling pointer p is pointing. The program counter increments to line 10, and the program ends",
    tipStart: 14,
    tips: [
      "Finally at line 9, the program prints the dereferenced value of <strong>p</strong> which will contain the value '20' from the stale area of memory to which the dangling pointer <strong>p</strong> is pointing",
      "The program counter increments to line 10, and the program ends"
    ]
  }
];

What is wrong with this code?

```cpp
#include<cstdio>

int *get_pointer()
{
  int value = 10;
  int *result = &value;
  return result;
}

int main()
{
  int *p = get_pointer();

  printf("%d\n", *p);
}
```

There is something bad here, but this will compile without warnings and will run and output the value 10.

Here is a hint. The following version prints 20, not 10!

```cpp
#include<cstdio>

int *get_pointer()
{
  int value = 10;
  int *result = &value;
  return result;
}

int get_value()
{
  int result = 20;
  return result;
}

int main()
{
  int *p = get_pointer();

  int other = get_value();

  printf("%d\n", *p);
}
```

Think about what is happening in memory here, and think back to the details on [the stack](/book/part-2-organised-code/2-organising-code/2-trailside/05-the-stack) and how that works.

The problem relates to variable scope and lifetime.

## Dangling Pointers

Lets step through the actions of `get_pointer`. This creates a variable, `value`, and assigns it the value 10. This is allocated on the stack, which is within the current function call. We then create a `result` pointer and get it to point to the `value` variable. Then we return the `result`, which points to `value` in the `get_pointer` data on the stack. At this point, `get_pointer` has ended, and it is removed from the stack. Removing its allocation for the `value` variable. The pointer we returned is now pointing to memory that is not actually allocated to anything!

This is referred to as a **dangling pointer**, which is a pointer that does not point to a valid value. It was valid, up until the `get_pointer` function returned.

So why did the first version seem to work? The problem here is that the location where `value` was stored has not yet been used for anything else. So it *happens* to still have the same value (10). In the second version, the `get_value` function was called, and this overrode the same location in memory for its result variable. Now when you dereference `ptr` in main, you get the new value 20.

When working with pointers you need to be careful **never** to return a pointer to something you have allocated on the stack. It is probably ok to pass pointers to stack values to parameters, but returning these pointers is always going to cause problems. The challenge can be that it will work for some time, and then strangely break for no apparent reason. So this is one of those places where you need to make sure these errors do not occur.

:::tip

When working with pointers, keep value lifetime in your mind. Remember that local variables are *destroyed* at the end of the function or procedure call. Make sure that any pointers to these stack values are not saved, or returned to places where they can be accessed after the local variable is destroyed.

:::

## Dangling Pointers Up Close

<MySwiper client:only height="" images={sliderDanglingPointer}></MySwiper>
