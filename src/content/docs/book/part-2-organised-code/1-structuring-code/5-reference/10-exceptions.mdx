---
title: Exceptions
banner:
    content: |
        Advanced topic! You may want to skip this and return later...
---

import MySwiper from "/src/components/react/myswiper.jsx";

import Slide1 from "./images/exception-slider/slider-1.png";
import Slide2 from "./images/exception-slider/slider-2.png";
import Slide3 from "./images/exception-slider/slider-3.png";
import Slide4 from "./images/exception-slider/slider-4.png";
import Slide5 from "./images/exception-slider/slider-5.png";
import Slide6 from "./images/exception-slider/slider-6.png";
import Slide7 from "./images/exception-slider/slider-7.png";
import Slide8 from "./images/exception-slider/slider-8.png";
import Slide9 from "./images/exception-slider/slider-9.png";
import Slide10 from "./images/exception-slider/slider-10.png";
import Slide11 from "./images/exception-slider/slider-11.png";
import Slide12 from "./images/exception-slider/slider-12.png";

export const ExceptionSwiper = [
    {
        src: Slide1.src,
        altText:
            "Try block registers exception handler",
        tipHeader: "Try is encountered",
        tips: [
            "Try block registers we have catch blocks",
            "The <code>check</code> variable is created in main",
        ],
    },
    {
        src: Slide2.src,
        altText:
            "Shows call to double_positive(5)",
        tipHeader: "Normal Path",
        tips: [
            "Here we pass 5 to double_positive",
            "This will let us see the normal behaviour",
        ],
    },
    {
        src: Slide3.src,
        altText:
            "In double_positive we do not throw an exception",
        tipHeader: "Normal Path - no exception",
        tips: [
            "Value is not less than 0, so we skip the code that throws",
        ],
    },
    {
        src: Slide4.src,
        altText:
            "10 is returned as normal",
        tipHeader: "Normal Path - value returned to caller",
        tips: [
            "We return 10 back to the caller - main",
        ],
    },
    {
        src: Slide5.src,
        altText:
            "Catch is skipped",
        tipHeader: "Normal Path - catch skipped",
        tips: [
            "When we get to the end of the try block, we skip the catch blocks.",
            "The catch statements are only executed if an exception is thrown",
            "This should be the case most of the time",
        ],
    },
    {
        src: Slide6.src,
        altText:
            "Calling double_positive with a negative value",
        tipHeader: "Exception Path - calling with negative value",
        tips: [
            "When we get to the end of the try block, we skip the catch blocks.",
            "The catch statements are only executed if an exception is thrown",
        ],
    },
    {
        src: Slide7.src,
        altText:
            "Throw occurs in double_positive",
        tipHeader: "Exception Path - exception thrown",
        tips: [
            "Value is less than 0, so we throw the message",
            "Message is a string - not shown in the illustration",
        ],
    },
    {
        src: Slide8.src,
        altText:
            "Throw jumps into the exception handling code",
        tipHeader: "Exception Path - exception back up stack for catch",
        tips: [
            "The exception handling code takes over, and will search back up the stack for a handler",
            "double_positive ends, as there is no catch here",
        ],
    },
    {
        src: Slide9.src,
        altText:
            "Try is found in main",
        tipHeader: "Exception Path - try is found in main",
        tips: [
            "Try is found in main - so the handler checks for a matching catch",
            "We threw a string, and there is a matching block",
            "Control will now continue within this catch block",
        ],
    },
    {
        src: Slide10.src,
        altText:
            "Exception is caught",
        tipHeader: "Exception Path - catch takes over",
        tips: [
            "Space for <code>e</code> is allocated on the stack",
            "<code>e</code> is given the value thrown",
            "The code in the catch is run",
            "Other catch blocks will be skipped, if any exist",
            "Execution will continue as normal from here",
        ],
    },
    {
        src: Slide11.src,
        altText:
            "Example where we throw an uncaught exception",
        tipHeader: "Uncaught Exception Path - what if we throw an int in this case?",
        tips: [
            "If we change double_positive to throw an int",
            "There is no matching catch",
        ],
    },
    {
        src: Slide12.src,
        altText:
            "Exception causes main to end and program to terminate",
        tipHeader: "Uncaught Exception Path - main ends as well",
        tips: [
            "As there is no catch block to use, the current function ends too",
            "This would continue to search further back in the stack, if there were more stack frames",
            "In this case, when main ends the program terminates",
            "The exception handler then outputs a message to help us understand what happened",
        ],
    },
];

Exceptions provide an alternate pathway to exit a function/procedure, one that is taken when there is an error or issue that means the function cannot perform its actions as normal.

## Exceptions -- when, why, and how

You should avoid using exceptions as much as possible, but they are useful when you start building libraries or other components where you do not have full control of how the code works. In these cases you can use exceptions as a way of saying "I can't do what you are asking...".

For now, it is good to keep in mind that code you call may also throw exceptions.

## In C/C++

:::tip[Syntax]

In C/C++ you can throw any type of data. The syntax is `throw` followed by the data to use as the exception.

To catch, you need a `try` block followed by one or more `catch` blocks. In each catch you can specify the type of exception to catch by declaring a variable to store the exception within the catch block's parenthesis. You can also catch any exception using `catch(...) { }`.

:::

### Throwing an exception

The following Illustration shows a `double_positive` function that expects the passed in values to be 0 or larger. In this case, we can check if the value passed in is less than 0 and throw an exception if that is the case. Here we throw a string message, so that the caller can have some context on what went wrong.

![Illustration of code highlighting throw](./images/throw.png)

:::note

- Exception is a *term* given to the data you can "throw" from a function or procedure.
- In your code, `throw` can be used to exit the current block, and search for an error handler in the calling code.
- Due to the way strings are handled in C++ it will be best to store the message in a variable, and then throw the variable. Alternatively you can use `throw string("Message");`.

:::

### Catching an exception

Exceptions have added an alternate exist path from a function, so how can you handle these exceptions in the calling code?

In keeping with the *throwing* metaphor, the code to handle an exception is called a `catch` block. In C++, you wrap the code where an exception may be thrown within a `try` block, which may then be followed by one or more `catch` blocks to handle different kinds of exceptions. When an exception is thrown within the try block, the alternate return path searches for the matching catch block where execution then continues. Given it must search for a matching catch, exceptions will keep returning from each function until a matching catch is found or there are no calls left to terminate.

![Illustration of code catching the exception](./images/catch.png)

:::note

- To handle an exception, wrap the code where the exception may occur within a `try` block.
- Think about where you want the error to be handled, adding any following statements you want skipped when the error occurs within the try block as well.
- At the end of the try block, place a `catch` block with the matching data type of the type thrown by the called code.
- Within the catch block you can place any code you want to occur when the error is caught. This code is a bit like an else branch, in that it will be skipped if the exception does not occur.
- You can add a `catch(...)` to catch any exception.

:::

### Exception propagation

Exceptions require a `catch` block to provide the point to return to. As a result, if there is not a matching catch block (based on the type of the exception) then the exception must keep ending each function/procedure until it gets back to a point where a matching catch block exists. This process can cause the program to terminate, with the language tools then outputting a message to indicate that the program terminated due to an exception.

:::tip{Reflect}

Think back to our earlier code where attempting to convert user input to an integer or double could cause the program to terminate. This was the result of an unhandled exception. The conversion functions returned the number when it could, but when it could not, it threw an exception which we could have handled.

While we know how to handle exceptions now, the approach we used earlier is still preferred. In general, you are best **not** to use exceptions if you do not need to. So checking and then performing the action is still the better approach.

:::

## Example

This code demonstrates throwing and catching exceptions. The `double_positive` function requires a positive value to be passed to it. When `value` is less than 0, the function throws a string exception message. Throwing the exception ends the function, returning to the caller (`main` in this case) to search for a valid handler (`catch` block).

```cpp
#include "splashkit.h"

using std::to_string;

/**
 * Double the passed in positive value
 *
 * @param value a positive integer
 * @return int double value
 * @exception string if value is less than 0
 */
int double_positive(int value)
{
    // Check that value is not negative
    if (value < 0)
    {
        // We have a problem - set a message to return
        string message = "Value must be positive";
        // Throw the message as an exception - ending the function
        throw message;
    }

    return value * 2;
}

int main()
{
    int check;

    try
    {
        // Test calling double positive with a positive value
        check = double_positive(5);
        // This should succeed, and the doubled value printed
        write_line("Check is " + to_string(check));

        // Test calling double positive with a negative value
        check = double_positive(-1);
        // This should fail, so this code will be skipped
        write_line("Check is " + to_string(check));
    }
    catch(string e)
    {
        // Output the error when it occurs.
        write_line(e);
    }
    catch(...)
    {
        // Use ... to catch any other exception.
        write_line("Some other exception occurred");
    }

    // See what happens when an exception occurs outside of a handler.
    check = double_positive(-5);

    return 0;
}
```

When this code is executed you will get the following output on the terminal.

```sh
Check is 10
Value must be positive
libc++abi: terminating due to uncaught exception of type std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>
```

:::note

1. The first call succeeds, and the code continues as normal.
2. The second call fails, throwing a string exception. The exception is caught in the catch block, allowing the code to continue from there.
3. Call three also fails. As we are not in a try block, this also causes `main` to exit. As main is the entry point, there are no other calls to terminate, so the program ends with the exception.

:::

:::tip

We will explore exceptions further in later sections. For now, it should be sufficient to have a broad understanding of this alternate exit path. Refrain from using or handling exceptions for now.

:::

## Exceptions Up Close

The following images will step you through execution of the throw and catch mechanic.

<MySwiper client:only height="" images={ExceptionSwiper}></MySwiper>

:::note[Summary]

Exceptions are a structured mechanism that provide an alternate exit path from a function or procedure, one that is facilitated by the exception handling code provided by the language. The exception handler will search back through the stack for the first matching `catch` block, and it will return execution to that point. Where no matching catch blocks are found, the exception will terminate the program.

Avoid using exceptions where you can, but these will come in handy when you start to build reusable utilities.

:::
