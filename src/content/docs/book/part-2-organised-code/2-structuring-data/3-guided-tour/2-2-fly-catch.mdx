---
title: Catching the Fly
sidebar:
    label: " - Catching the Fly"
banner: 
  content: This is an optional tour - use it to extend your understanding.
draft: true
---
import { Accordion, AccordionItem } from 'accessible-astro-components'
import { Steps } from '@astrojs/starlight/components';
import NoCopy from '/src/components/NoCopy.astro'
import TemplateInjector from '/src/components/TemplateInjector.astro'
import MultipleChoice from '/src/components/MultipleChoice.astro';
import ITO from '/src/components/InlineTextOption.astro'
import Aside from '/src/components/Aside.astro'
import Carousel from '/src/components/Carousel.astro'
import Option from '/src/components/Option.astro';

Finally it's time to catch and eat the fly :)

Looking back at our outline of the game:

| **Name** | *Fly Catch* |
|---|---|
| **Description** | A small game where the user controls a spider using the keys on the keyboard. The user can move the spider around on their web, catching each fly as it appears. Take too long, and the fly escapes. |

<Aside type="thinking" title="Let's plan">
- We can see that the fly needs:
    - to appear somewhere random (caught in the web)
    - wait some amount of time
    - and then disappear.

    Another way of thinking about it, is that there's a _time interval_ within which the fly is catchable - we could store this interval as data, and update it whenever we want the fly to reappear.

- We'll also need some way to know whether the fly is _currently_ caught and can be eaten or not - this could be a field (but where should we put it?)

- Finally, we'll need a way to update the fly:
    - we should make sure it's visible during the time interval
    - once the interval ends, we should hide it, reposition it, and shift the time interval to somewhere in the future (so it shows up again).

    This could be a procedure that takes a `fly_data` by reference, and updates it.
</Aside>

Let's get started!

<Steps>

1. ### Creating `timespan`

    First off, we have our "timespan", with a `start` and `duration`. Thinking of it this way gives us a struct to make - we could make a `timespan` struct that our `fly_data` has as a field (`timespan caught_interval;`), which tells us when the fly will next appear as caught in the web, and how long for.

    :::tip
    Note again how, rather than just placing the `start` and `duration` directly inside `fly_data`, we've abstracted that out by one level, by creating a `timespan` struct that we could re-use in other situations.

    **This sort of early abstracting doesn't always pay off, but it's good to consider and be ready to refactor as necessary.**
    :::

    Recall from Explore Structs (GUI) that we can use `current_ticks()` to get the number of milliseconds since the game started as a `long` - we'll continue using `long` as the type for times. Let's go ahead and make this struct now, and add it as a `caught_interval` field in `fly_data`:

    |   |   |
    |---|---|
    | **Struct** | *timespan* |
    | **Fields** | `start`: (long) The starting time |
    |            | `duration`: (long) The duration |

    <Accordion>
    <AccordionItem header="Creating timespan">
        ```c++
        struct timespan
        {
            long start;
            long duration;
        };
        ```

        Timespan struct, fairly straightforward. We can see how `fly_data` represents our fly clearly - it's an entity that exists in the world, and it has an interval during which it is considered "caught" (in the web).

        ```c++ {4}
        struct fly_data
        {
            entity ent;
            timespan caught_interval;
        };
        ```
    </AccordionItem>
    </Accordion>

2. ### Writing `timespan` utility functions

    Let's also now add two utility functions:

    |   |   |
    |---|---|
    | **Function** | *Within Timespan* |
    | **Description** | Takes a timespan and a time, and returns whether the time is inside the interval or not.|
    | **Return** | A `boolean` |

    and

    |   |   |
    |---|---|
    | **Function** | *After Timespan* |
    | **Description** | Takes a timespan and a time, and returns whether the time is _after_ the interval or not.|
    | **Return** | A `boolean` |

    :::tip[Generality vs Ergonomics]
      Note again that we accept both a `timespan` _and_ a time (a `long`).

      We could just use `current_ticks()` inside the functions instead, but this way we can test _any_ time against the timespan, which may be helpful later on. However, it does make using it a less convenient.

      For general use, often overloads can make things more ergonomic - for instance having a `within_timespan(const timespan &span, long time)` _and_ a `within_timespan(const timespan &span)`, that looks like:
      ```c++
      bool within_timespan(const timespan &span)
      {
          return within_timespan(span, current_ticks());
      }
      ```
      See how it just calls the other version of `within_timespan`, and uses `current_ticks()` as the default value? This is a really useful pattern to keep in mind - feel free to try it here!
    :::

    Have a go at writing these functions yourself :)
    :::tip
      Use a combination of boolean operators to test `time` against the `timespan` `start` and end (which is `(start + duration)`).
    :::

    <Accordion>
    <AccordionItem header="Within/After Timespan">
        I wrote a fairly terse implementation, but feel free to write one that's more expanded.
        ```c++
        bool within_timespan(const timespan& span, long time)
        {
          return time > span.start && time <= (span.start + span.duration);
        }

        bool after_timespan(const timespan& span, long time)
        {
          return time > (span.start + span.duration);
        }
        ```
    </AccordionItem>
    </Accordion>

2.  ### Testing `timespan`
    Before continuing, let's test this out. We'll have to update our `fly = {...}` initialization in `new_fly`. Let's try initializing the fly to show up from 1 seconds in (1000 milliseconds), and stay for 3 seconds (3000 milliseconds).

    Here's the answer (because it's not great):
    ```c++ ", {1000, 3000}"
    fly = {{
      {100, 100},
      15, COLOR_GREEN
    }, {1000, 3000}};
    ```

    This...is not readable anymore. Let's split it onto two lines instead - try initializing `fly.ent` and `fly.caught_interval` on separate lines.

    _TODO: Perhaps there's a better way of testing this that is less confusing_

    Now let's **temporarily** modify `draw_game` to only draw the fly during its `caught_interval`. Add an `if` statement around the fly's `draw_entity` statement, and test its `caught_interval` against `current_ticks()` using `within_timespan`.

    If all is working right, the fly should be invisible for the first second, and then appear for three seconds before disappearing again! If not, it'll be time to debug :)

    :::tip
    Temporarily modifying code like this to debug can be really helpful, but be careful not to become confused about what was changed.
    :::

3. ### Showing/hiding _entities_
    What we've done in `draw_game` to hide/show the fly _works_, but is it good design? Let's consider that when the fly is caught in the web, two things change:
      1. It becomes visible
      2. The spider can now collide with it to eat it.

    What this means is that we'll have to use this value of "caught" in multiple places. So fitting with the theme of this tutorial, we will aim to store it as data.
    - We could add a `bool visible;` field to `fly_data`, however, is being visible really a property of the `fly_data`?
    - It's actually the _entity_ that is being drawn, so we'll add it to the `entity` struct instead.
    - Additionally, it's not _only_ controlling visibility, but also whether the spider can interact with it. So let's call the field `enabled` instead.

    The digital reality we are creating now is that any `entity` can be `enabled` or not, which seems reasonable.

    Add a `bool enabled;` field to `entity`, and update your `new_spider` and `new_fly` to set it. Let's make the spider set `enabled` to `true`, while the fly will have `enabled` set to `false` (hidden at first).

    Now we can remove the `if (within_timespan(game.fly.caught_interval, current_ticks()))` from `draw_game`. Instead, we can test inside `draw_entity` if `ent.enabled` is `false` - if so, we can just return from the procedure right away without drawing anything.

    Have a go at all that - if it's working, the fly should be invisible (and stay invisible), and the spider will be visible. Try changing the `enabled` value on the fly and spider, and make sure it's working right.

    <Accordion>
    <AccordionItem header="Within/After Timespan">
        I added the `enabled` field to the top of my `entity` struct, since it feels like an important property.
        ```c++ {3}
        struct entity
        {
            bool enabled;

            point_2d pos;
            ...
        }
        ```

        I modified `new_spider` and `new_fly` accordingly.
        ```c++ "true"
        spider_data new_spider()
        {
          spider_data spider;

          spider.ent = {
            true,
            {100, 100},
            15, COLOR_GREEN
          };

          return spider;
        }

        ```

        Then I removed the `if` statement from `draw_game`, and instead added one inside `draw_entity`.
        ```c++ {3-7, 17-19}
        void draw_entity(const entity &ent)
        {
            // Exit if the entity is disabled
            if (!ent.enabled)
            {
                return;
            }

            fill_circle(ent.clr, ent.pos.x, ent.pos.y, ent.radius);
        }

        void draw_game(const game_data &game)
        {
            // Draw the game
            clear_screen(COLOR_WHITE);

            // Draw the game entities
            draw_entity(game.spider.ent);
            draw_entity(game.fly.ent);

            // Show it to the user
            refresh_screen();
        }
    ```
    </AccordionItem>
    </Accordion>

4. ### Catching and eating the fly
    TODO
</Steps>


### Final Program
This is here as a reference while writing.

TODO: Remove

```c++
#include "splashkit.h"

const int SCREEN_WIDTH = 1280;
const int SCREEN_HEIGHT = 720;

const int SPIDER_RADIUS = 25;
const int SPIDER_SPEED = 3;

const int FLY_RADIUS = 10;

struct entity
{
  bool     active;

  point_2d pos;
  double   radius;

  color    clr;
};

struct timespan
{
  long start;
  long duration;
};

struct fly_data
{
  entity   ent;
  timespan lifespan;
};

struct spider_data
{
  entity ent;
};

struct game_data
{
  spider_data spider;
  fly_data    fly;
};

entity new_entity(bool active, point_2d pos, double radius, color clr)
{
  return {active, pos, radius, clr};
}

void draw_entity(const entity &ent)
{
  // Exit if the entity has not appeared
  if (!ent.active)
  {
    return;
  }

  // Draw the fly
  fill_circle(ent.clr, ent.pos.x, ent.pos.y, ent.radius);
}

void draw_game(const game_data &game)
{
  // Draw the game
  clear_screen(color_white());

  // Draw the spider
  draw_entity(game.spider.ent);

  // Draw the fly
  draw_entity(game.fly.ent);

  // Show it to  the user
  refresh_screen(60);
}

spider_data new_spider()
{
  spider_data result;

  // Set the spider in the center of the screen
  result.ent = new_entity(
                    true,
                    {SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2},
                    SPIDER_RADIUS,
                    COLOR_BLACK
                );

  return result;
}

fly_data new_fly(long time)
{
  fly_data result;

  result.ent = new_entity(
                    false,
                    {(double)rnd(SCREEN_WIDTH), (double)rnd(SCREEN_HEIGHT)},
                    FLY_RADIUS,
                    COLOR_GREEN
                );

  result.lifespan = {time + 1000 + rnd(2000), 2000 + rnd(5000)};
  return result;
}

bool within_timespan(const timespan& span, long time)
{
  return time > span.start && time <= (span.start + span.duration);
}

bool after_timespan(const timespan& span, long time)
{
  return time > (span.start + span.duration);
}

bool entities_collide(const entity &ent1, const entity &ent2)
{
  return ent1.active && ent2.active && circles_intersect(
    ent1.pos.x, ent1.pos.y, ent1.radius,
    ent2.pos.x, ent2.pos.y, ent2.radius);
}

void move_with_keyboard(entity &ent, double speed)
{
  if (key_down(RIGHT_KEY) && ent.pos.x + ent.radius < SCREEN_WIDTH)
  {
    ent.pos.x += speed;
  }
  if (key_down(LEFT_KEY) && ent.pos.x - ent.radius > 0)
  {
    ent.pos.x -= speed;
  }

  if (key_down(DOWN_KEY) && ent.pos.y + ent.radius < SCREEN_HEIGHT)
  {
    ent.pos.y += speed;
  }
  if (key_down(UP_KEY) && ent.pos.y - ent.radius > 0)
  {
    ent.pos.y -= speed;
  }
}

void update_fly(fly_data &fly, long current_time, bool caught)
{
  fly.ent.active = within_timespan(fly.lifespan, current_time);

  if (caught || after_timespan(fly.lifespan, current_time))
  {
    fly = new_fly(current_time);
  }
}

void update_game(game_data &game, long current_time)
{
  bool caught = entities_collide(game.spider.ent, game.fly.ent);

  update_fly(game.fly, current_time, caught);
}

int main()
{
  game_data game;

  game.spider = new_spider();
  game.fly = new_fly(current_ticks());

  open_window("Fly Catch", SCREEN_WIDTH, SCREEN_HEIGHT);

  // The event loop
  while (!quit_requested())
  {
    move_with_keyboard(game.spider.ent, SPIDER_SPEED);
    update_game(game, current_ticks());
    draw_game(game);

    // Get any new user interactions
    process_events();
  }

  return 0;
}
```
