---
title: Generic Array with Operator Overloads
sidebar:
    label: " - Adding Operator Overloads"
---
import { Accordion, AccordionItem } from 'accessible-astro-components'
import { Steps } from '@astrojs/starlight/components';

## Improving `get(...)`

The functionality of our generic array is fairly solid now. However, we can improve the _ergonomics_ (ease of use) of our class - particularly, we can make our:
```c++
my_array.get(2) = 20;
```
look like:
```c++
my_array[2] = 20;
```
by using operator overloads. This will make our generic array really look and feel like an array!

### Before we do that...

Before we add our operator overloads, there's actually an issue with our `get` function we should handle first.

Try this out for yourself to see the issue - first, briefly read this `test_const_array` procedure:
```c++
void test_const_array(const bounded_array<double, 50> &my_array)
{
    write_line(my_array.get(0));
}
```

It's a simple procedure - a `bounded_array<double, 50>` is passed as a `const` reference, and the first element is printed. Paste in the code above `main` and try compiling it!

...

Did you try it out? If so, you'll have seen that we get an error! It will look like this:
```sh
your_file.cpp:...:error: 'this' argument to member function 'get' has type 'const bounded_array<double, 50>', but function is not marked const
    write_line(my_array.get(0));
               ^~~~~~~~
```

What the compiler is telling us, is that that:
- `my_array` is passed as a const (`has type 'const bounded_array...`)
- but our `get` function doesn't promise that it won't change `my_array` (`but function is not marked const`).

This is fair, since it's true that if use `get` like this:
```c++
my_array.get(0) = 20;
```
the `get` function is indirectly allowing us to modify the array.

It is a bit frustrating that the compiler can't automatically figure out that `write_line(my_array.get(0))` isn't going to modify `my_array`, but luckily we can tell it. To solve this issue, we'll have _two_ `get` functions.
 - The one we have currently will stay the same - it returns a reference that can be used to modify the array.
 - The second one will be almost identical. However, it will return a `const` reference, and the function itself with be marked as const.

Compare the two signatures to understand this:
```c++
    T& get(int index);
    const T& get(int index) const;
```

It isn't ideal that we have to duplicate the function, but luckily `get` isn't too complicated. Have a go at this, and get that `test_const_array` procedure working.

Now let's get our index operators working! We'll implement them using `get`, so this has laid the groundwork for us :)

## Adding Index Operators
Adding support for using the array access operator (e.g. `[0]`) basically just involves adding another method to our `bounded_array` class. The syntax can look a little strange at first, but take a look at the signatures of the methods we'll add:

```c++
T& operator[](int index);
const T& operator[](int index) const;
```

The `operator` part is just saying "this method is overloading...an operator!", and the `[]` is the operator that is being overloaded. You'll notice we also have two of them again, for the same reason we have two `get` methods.

The actual body of these methods will be very straightforward - we can just call `get(index)` and return the result!

Have a go at implementing these two methods now - their body should only be a single line of code :)


<Accordion>
  <AccordionItem
    header="Generic array with [] operators"
  >

```cpp {22,28,30,34,125,128-144,146-162}
template<typename T, int MAX_CAPACITY>
class bounded_array
{
    ...

    T& get(int index) { ... }
    const T& get(int index) const { ... }

    T& operator[] (int index)
    {
        return get(index); // this will call `T& get(int index)`
    }

    const T& operator[] (int index) const
    {
        return get(index); // this will call `const T& get(int index) const`
    }
};
```
Each `operator[]` just forwards its parameter to the respective `get`, and returns the result.

  </AccordionItem>
</Accordion>

## Wrap up
For now that's all for our generic array - it's now useable with any type, and looks and handles similar to a normal array. In the next chapter we'll look at creating another type we can use to store _lists_ of elements, and finally in Deep Dive Memory we'll further develop the generic array to support dynamically resizing to store _any_ number of elements, potentially billions.

---

### Note on Operator Overloads

Operator overloads are pretty powerful! You _could_ overload various operators, like `+`, `()`, `|`, etc. Many programmers however are against this, since it can be ambiguous as to what the operator should do.

Take `+` for instance. If we added a `+` operator to our array class, what should it do? It could:
 - _Append_ two arrays together. For instance `[4, 6, 1] + [6, 3, 2] = [4, 6, 1, 6, 3, 2]`
 - _Element-wise add_ the two arrays. For instance `[4, 6, 1] + [6, 3, 2] = [10, 9, 3]`
 - _Union_ the unique elements. For instance `[4, 6, 1] + [6, 3, 2] = [4, 6, 1, 3, 2]`
 - And more...

And all of these choices are reasonable! So a common guideline is to prefer _named_ methods rather than operator overloads, to reduce ambiguity.

:::tip
_Personally_, I think that operator overloads can be perfectly fine within a well designed class, and that the arguments against them are overstated. There are programmers that argue against even the `+` operator for `string`, but I think most of us appreciate the improved ergonomics :)
:::
