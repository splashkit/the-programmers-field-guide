---
title: Constructors
sidebar:
    label: " - Constructors"
---
import CodeScroll from '/src/components/CodeScroll.astro'

The constructors are probably the trickiest of the members to consider, but let's start with them anyway as we need to see how objects (struct values) are initialised before we start to perform other actions on them.

A constructor is a special method that is used to initialise an object created from the struct.

## Constructor - Why, When, and How

When you start to work more within the struct, it is probably always a good idea to create a constructor that can initialise everything just the way you want. This can accept parameters, and use the provided values to set fields of the object when it is created, or it can just allocate default values that make sure things work as expected. In any case, the idea is to make sure that each object is always set up in a way that will mean it works straight away.

In our example code, the `new_contact` function performed the same role in the original struct code. This can be coded into the constructor in our contact. This will initialise each object created from the struct, ensuring that it always has valid data within it.

:::tip[Object?]

Remember that the term **object** refers to a value created from a struct. We use this when thinking about these values as they now *know* and *can do* things based on the fields and methods declared within the struct. In this way the struct is like the template, and the object is created in memory using this template. In C++ objects can be allocated on the stack, or on the heap (which will be covered in [Pointers & Lists](/book/part-2-organised-code/6-indirect-access/0-overview/)).

:::

## Destructors

Similar to constructors, you can also hook into the code that occurs when the object is destroyed, for instance when a stack based object goes out of scope.

You would use the code in the destructor to clean up any additional memory, or other resources, allocated to your object.

## In C++

:::tip[Syntax]

Constructors are coded in the struct as a special looking function. It does not specify any return type, and it uses the same name as the struct for its function name. Destructors are similar, but start with a `~` and can not have any parameters.

![Constructors are coded as special functions in the struct](./images/constructor.png)

:::

## Example

Here is another example of a struct with some fields, a constructor, and a method.

<CodeScroll maxHeight="650px">
```cpp
#include "splashkit.h"

struct stock
{
    // The fields are created in the struct, so they are directly accessible
    // within the struct itself.
    string id;
    int value;

    /**
     * The constructor initialises the stock with
     * the supplied id and value.
     *
     * @param id_init the id to initialise the stock with
     * @param value_init the value to initialise the stock with
     */
    stock(string id_init, int value_init)
    {
        // We are inside the struct - so we can access id and value
        id = id_init;
        value = value_init;
    }

    ~stock()
    {
        write_line("Stock destroyed - " + id);
    }

    /**
     * Adjust the value by the indicated amount.
     *
     * @param diff the amount to change the value by
     */
    void adjust_value(int diff)
    {
        // We can update the value of the struct
        // methods are always run on the stock object itself...
        value += diff;
    }

    void print() const
    {
        write_line(id + " $" + to_string(value) );
    }
};

void print_largest_stock(const stock &s1, const stock &s2)
{
    // Struct fields are public by default, so we can
    // access them directly as usual too.
    if (s1.value > s2.value)
    {
        s1.print();
    }
    else if (s2.value > s1.value)
    {
        s2.print();
    }
    else
    {
        write_line("The stock are identical.");
    }
}

int main()
{
    // s1 will use the constructor we created to initialize its values.
    stock s1("TEST", 123);
    
    s1.adjust_value(-4);
    s1.print();

    // We can also construct objects temporarily and use them in expressions.
    // This passes s1, and also a temporary `stock` object,
    // into `print_largest_stock`.
    print_largest_stock(s1, stock("Apples", 64));

    return 0;
}
```
</CodeScroll>

Looking at this, the syntax for using the constructor is a little strange, and makes the variable declaration look like a function call. You have to remember that in these cases you are calling the constructor.

Also note that in this example, we could no longer write only:
```c++
stock s1;
```

We would *have to* call the constructor, as `stock` has no constructor with zero parameters (which is also known as the **default constructor**). If you want to be able to declare a stock variable without having to pass in the stock id and value, then you can add a second constructor that takes no parameters and initialises the id and value to some set defaults.

:::tip[Initializing variables in C++]
C++ actually has _many_ initialization forms:
```c++
stock s1("TEST", 123);         // direct-initialization - what we're using currently
stock s2{"TEST", 123};         // direct-list
stock s3 = stock("TEST", 123); // copy-initialization
stock s4 = {"TEST", 123};      // copy-list
```

And multiple ways to construct objects within expressions:
```c++
use_stock_function( stock("TEST", 123) );
use_stock_function( stock{"TEST", 123} );
use_stock_function( {"TEST", 123} );
```

This is a result of the language evolving over time. There are subtle differences between how exactly each one works, but for now there's no need to delve into this.

However, being able to recognise them will be helpful when reading other pieces of code.
:::


[/* TODO: add slider */]:#

