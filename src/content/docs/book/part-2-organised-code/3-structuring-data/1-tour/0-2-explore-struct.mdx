---
title: Explore Structs Terminal
sidebar:
    label: " - Explore Structs (Terminal)"
---
import { Accordion, AccordionItem } from 'accessible-astro-components'

Structs are a great way of being able to capture all the data for something (an entity) related to your program. Let's explore how to create and use a struct with a terminal application.

In this program we will use a struct to represent a student's result in a unit at university. We can then add a function to read in this data from the user and a procedure to write it out to the terminal.

## Unit result struct

As we have seen [the previous task](/book/part-2-organised-code/3-structuring-data/1-tour/0-2-explore-struct), we need to first consider what entities we want to work with.

In our case, want to be able to see a student's results in a unit. This tells me that I likely want the unit's name, code, and somewhere to store the numerical score the student achieved in the unit.

|   |   |
|---|---|
| **Struct** | *unit_result* |
| **Fields** | `unit_code`: (string) The code of the unit, e.g. FIT1045 |
|            | `unit_name`: (string) The name of the unit, e.g. Introduction to programming |
|            | `score`: (integer) The student's score in the unit.  |

From here, all we need to do is define a struct, some functions and procedures to read in input from the user to store in a struct, and a procedure to print out the values (fields) of the struct. Here is a basic `main` to get you started. It highlights the intended functionality we want to achieve.

Declare the `unit_result` struct to get started with this change.

```cpp
#include "splashkit.h"

// Declare struct here

// Declare other functions and procedures here

int main() 
{
  // Create a local variable for your result here...
  // unit_result result;

  // We can then read in a value
  // result = read_unit_result();

  // And output it to the terminal
  // write_unit_result(result);

  return 0;
}
```

<Accordion>
  <AccordionItem
    header="Code for unit_result struct"
  >

```cpp
struct unit_result
{
  string unit_code;
  string unit_name;
  int score;
};

```

  </AccordionItem>
</Accordion>

Running this by itself won't work yet just, because we still need to declare our other functions and procedures.

## Defining a function to read a unit result

For this, we can reuse the `read_string`, and `read_integer` functions we created in our [utilities](/book/part-2-organised-code/2-organising-code/1-tour/04-00-utilities). Add the necessary `#include` or copy these in if needed.

Now we can build a `read_unit_result` function. This function will contain the code needed to read in values for all the fields in a `unit_result` and return this to the caller. You can think of it like `read_string` or `read_integer`, just in this case it is reading a `unit_result` value. Here is a description of what this will need to do.

|   |   |
|---|---|
| **Function** | *Read Result* |
| **Description** | Prompts the user for input for the unit code (string), unit name (string), and score (double). Use these values to initalise and return `unit_result` struct. |
| **Return** | A `unit_result` struct with initialised fields for unit name, unit code and score. |

Have a go at creating this function, and call it from within `main`. Store the data returned from `read_user_result` in a local variable so that we can use it later.

:::tip

Make use of the functions you created in your [utilities](/book/part-2-organised-code/2-organising-code/1-tour/04-00-utilities). These can handle reading in the individual field data for the struct.

:::

<Accordion>
  <AccordionItem
    header="Code for a read_unit_result function"
  >

```cpp
unit_result read_unit_result()
{
    unit_result result;

    result.unit_code = read_string("Enter unit code: ");
    result.unit_name = read_string("Enter unit name: ");
    result.score = read_integer("Enter your score: ");

    return result;
}
```

  </AccordionItem>
</Accordion>

## Defining a procedure to output a user result

Now we have the data in the struct a procedure to write this to the terminal may be useful. Let's create a `write_unit_result` procedure to output these results to the terminal. Then you can update your `main` to output the result that we read in.

|   |   |
|---|---|
| **Procedure** | *Write User Result* |
| **Description** | Outputs the details of the user result in the format "unit code, unit name, score". Where the score is larger than or equal to 80 the message "congratulations" is added to the end. |

<Accordion>
  <AccordionItem
    header="Code for a write_unit_result function"
  >

```cpp
void write_unit_result(unit_result result)
{
    write(result.unit_code + ", " + result.unit_name + ", " + to_string(result.score));

    if (result.score >= 80)
    {
      write_line(" congratulations");
    }
    else
    {
      write_line();
    }
}
```

  </AccordionItem>
</Accordion>

Make sure to build and run your program. You should be prompted for input for the relevant fields, and see them printed out to the terminal.

Now, we have a struct that contains all the fields relating to a student's store in the unit. Structs are a powerful tool to help encapsulate data that relates to a common entity (in this case, a unit result!)

Here is my code for this in case you got stuck.

<Accordion>
  <AccordionItem
    header="Code for a write_unit_result function"
  >

```cpp
#include "splashkit.h"
#include "utilities.h"

using std::to_string;

struct unit_result
{
  string unit_code;
  string unit_name;
  int score;
};

unit_result read_unit_result()
{
    unit_result result;

    result.unit_code = read_string("Enter unit code: ");
    result.unit_name = read_string("Enter unit name: ");
    result.score = read_integer("Enter your score: ");

    return result;
}

void write_unit_result(unit_result result)
{
    write(result.unit_code + ", " + result.unit_name + ", " + to_string(result.score));

    if (result.score >= 80)
    {
      write_line(" congratulations");
    }
    else
    {
      write_line();
    }
}


int main() 
{
  // Create a local variable for your result here...
  unit_result result;

  // We can then read in a value
  result = read_unit_result();

  // And output it to the terminal
  write_unit_result(result);

  return 0;
}
```

  </AccordionItem>
</Accordion>

## Test it out

As with the previous activity on structs, notice how easy this makes it to work with complex data types in the form of a struct, which can hold many other variables (called fields when inside a struct) in just one variable.

This problem is quite simple - but could easily be extended to model a more complex university setting. Each student has a student ID, email, units they are enrolled in, grades for each unit, and so on. Modelling this in software would be challenging without grouping them like we can with structs!

Hopefully this solidifies your understanding of structs when using them in a console-based program, where you may get input from the user or produce text output.
