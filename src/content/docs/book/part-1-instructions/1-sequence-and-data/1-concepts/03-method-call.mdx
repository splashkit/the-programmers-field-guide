---
title: "Method Call"
---
import MySwiper from '../../../../../../components/react/myswiper.jsx';
import Slide1 from './images/method-call-in-depth/Slide1.png';
import Slide2 from './images/method-call-in-depth/Slide2.png';
import Slide3 from './images/method-call-in-depth/Slide3.png';
import Slide4 from './images/method-call-in-depth/Slide4.png';
import Slide5 from './images/method-call-in-depth/Slide5.png';
import Slide6 from './images/method-call-in-depth/Slide6.png';
import Slide7 from './images/method-call-in-depth/Slide7.png';
import Slide8 from './images/method-call-in-depth/Slide8.png';
import Slide9 from './images/method-call-in-depth/Slide9.png';

export const sliderImages = [
  {
    src: Slide1.src,
    altText: "Program is loaded into memory, and ready to run",
    tipStart: 1,
    tips: [
      "The program has been loaded by the operating system, and its first instruction is now ready to go.",
    ]
  },
  {
    src: Slide2.src,
    altText: "Instruction 1 shows a method call with three arguments",
    tipStart: 2,
    tips: [
      "Instruction 1 is a method call with three arguments. Each method call has two steps: evaluate and load the arguments, then call the method.",
      "For this call we need to evaluate all three arguments, and load the results into registers 0 to 2. These are individual steps for the computer, so we can update the visualisation for these as 1a to 1c.",
      "Once the arguments are evaluated and loaded, we can start the method. This will be 1d."
    ]
  },
  {
    src: Slide3.src,
    altText: "Instruction 1 shows a method call with three arguments",
    tipStart: 5,
    tips: [
      "All arguments are literal values in this call. They need to be loaded into registers 0, 1, and 2 so they are in the CPU when the method starts. The first argument is the string literal \"Random Color\". It is loaded into the first register",
      "As with sequence before, the instruction counter is incremented as we step through each instruction. So 1a becomes 1b for our visualisation."
    ]
  },
  {
    src: Slide4.src,
    altText: "Evaluate and load arguments 2 and 3",
    tipStart: 7,
    tips: [
      "The second argument is loaded into register 1. Then the program counter is incremented to 1c.",
      "At 1c, we load the third argument into register 2. Then the program counter is incremented to 1d."
    ]
  },
  {
    src: Slide5.src,
    altText: "Save the old program counter so we can resume here when the call is done",
    tipStart: 9,
    tips: [
      "Instruction 1d will now start the method call. There are a few steps that the compiler takes care of, but it is good to see how this works.",
      "First we need to save the old program counter. When the method return this will be used to resume the code here."
    ]
  },
  {
    src: Slide6.src,
    altText: "Shows the CPU switching into the instructions of the called method",
    tipStart: 11,
    tips: [
      "The code for this method has also been loaded when the program started. So at this point, we can set the program counter to the address of the first instruction in the Open Window method.",
      "As the program counter is now in Open Windows instructions, those will run",
      "By convention, the arguments are loaded into the registers in order. So Open Window knows that it can access the title of the window in register 0, its width in register 1, and its height in register 2."
    ]
  },
  {
    src: Slide7.src,
    altText: "Shows the CPU at the end of Open Window's instructions",
    tipStart: 14,
    tips: [
      "When Open Window finishes, it will return to our method so that it can resume.",
      "At this point, the method has done its work. In this case, a window should have appeared for the user."
    ]
  },
  {
    src: Slide8.src,
    altText: "Shows the CPU restoring the old program counter from memory",
    tipStart: 16,
    tips: [
      "To get back to the previous instructions, the compiler adds in instructions to restore the old program counter. This will now move the computer back into the code where we called Open Window."
    ]
  },
  {
    src: Slide9.src,
    altText: "Shows the CPU continuing within the code we wrote",
    tipStart: 17,
    tips: [
      "Back in our code, the method call has ended",
      "The program counter increments",
      "We are now onto the next method call. This will evaluate arguments, the call the method. It will save the current state so that it can return here when the ClearScreen method finishes."
    ]
  },
]

A method call is an **instruction** that gets the computer to run the code in a [method](../03-method). You use the name of the method to identify which you want to run. Some methods require data, which you must **pass** as **arguments** to the method as part of the method call.

[Figure 5.3](#FigureMethodCall) shows the concepts related to the method call.

<a id="FigureMethodCall"></a>

![Figure 5.3 A method calls runs a method, passing in values for the method to use](./images/method-call-concept.png "A method calls runs a method, passing in values for the method to use")
<div class="caption"><span class="caption-figure-nbr">Figure 5.3: </span>A method calls runs a method, passing in values for the method to use</div><br/>

## Method Call - why, when, and how

As you have seen, [Methods](../03-method) are building blocks that contain instructions that do a task - sort of like mini-programs. A large part of your code will be calling these methods to get them to do the things you need done, in the order you need them done.

When you are thinking about calling a method, you need to know what it does, what to give it, and what it will give you back. The code is then simple, you provide the name and the list of values for arguments.

:::tip[Method Call]

- Know what the method does
- Know what you need to give it - arguments
- Know what it gives you back

:::

The name should help you know what the method does, and the method's documentation will help you understand what you need to provide the method for it to do its job.

### Arguments

When you call a Method, you need to pass a value for each argument. This value can be a [literal](../06-literal) or calculated value known as an [expression](../07-expression).

### Overloading

In languages like C# support something called **overloading**. This lets you create different methods with the same name, but requiring different arguments. If you are looking at the [SplashKit documentation](https://splashkit.io), you will see some methods require different arguments. So make sure to pay attention to which version of the method you want to call, and the arguments you will need to pass for that version.

### Method Calls and Sequence

Method calls are one instruction that gives you control of the **program counter**. A method call will save the current state of your program, and then set the program counter to the first instruction within the method. The sequence will then progress through the method, and when it ends, the location of the next instruction after the method call will be put into the program counter. In this way, the method is called and then **returns** to where it was called from. This allows us to maintain our focus on **sequence**. The method call lets you *direct* the sequence into the method and then back to your next instruction. As you read, design, or work with code for your program, you can focus on the program's **sequence** and not worry about what happens within the methods you call.

## In C#

A method call allows you to run the code in a [Method](../03-method), getting its instructions to run before control returns to the point where the method was called.

:::tip[Syntax]
[Figure 5.4](#FigureMethodCallSyntax) shows the syntax of a method call.

- A method call consists of a method name followed by an opening parenthesis, followed by zero or more arguments (delimited by commas), followed by a closing parenthesis.

<a id="FigureMethodCallSyntax"></a>

![Figure 5.4 The syntax of a method call](./images/method-call.png "The syntax of a method call")
<div class="caption"><span class="caption-figure-nbr">Figure 5.4: </span>The syntax of a method call</div><br/>
:::

## Examples

### Basic Example

The code in [Listing 5.6](#ListingMethodCalls) contains a C# program with four method calls. Each method call runs the `WriteLine` method to output text to the Terminal.

The method call starts with the method’s name that indicates the method to be called: `WriteLine`.

Following the identifier is a list of values within parenthesis (called **arguments**), these are the values that are passed to the method for it to use.

:::caution

C# is case sensitive so using `writeLine` instead of `WriteLine` will not work.

:::

<a id="ListingMethodCalls"></a>

```csharp
using static System.Console;

WriteLine("Count back from 2...");
WriteLine(2);
WriteLine(1);
WriteLine(0);
```

<div class="caption"><span class="caption-figure-nbr">Listing 5.6: </span>Method calls within a C# program</div>

### SplashKit Example

The following code uses three different methods from the [SplashKit](https://splashkit.io) library. You can see the details for these on the [Methods](../02-method) page, but the names should give you a good idea of what this does.

<a id="ListingDrawShapes"></a>

```csharp
using static SplashKitSDK.SplashKit;

DownloadSoundEffect("hello", "https://programmers.guide/hello.ogg", 443);
PlaySoundEffect("hello");
Delay(5000);
```

All of the arguments in this code are using literal values.

<div class="caption"><span class="caption-figure-nbr">Listing 5.x: </span>Playing a sound effect</div>

**TODO Add file to website and adjust url**

### Example using result

Some methods return data, which you can use within any calculated value ([expression](../07-expression)) within your code. The following code demonstrates the use of the values returned by the `RandomColor` and `Rnd` methods.

<a id="ListingReturn"></a>

```csharp
using static SplashKitSDK.SplashKit;

OpenWindow("Random Color", 800, 600);
ClearScreen(RandomColor());
RefreshScreen();
Delay(1000 * Rnd(10));
```

<div class="caption"><span class="caption-figure-nbr">Listing 5.x: </span>Code demonstrating use of return values.</div>

Line 4 demonstrates the use of the result from calling `RandomColor` within the call to `ClearScreen`. In this case, the value returned from the `RandomColor` becomes the value for the argument passed to `ClearScreen`. As you would expect, this will clear the screen to a random color.

Line 6 demonstrates this again, the result of `1000 * Rnd(10)` is passed to `Delay`. The easiest way to approach this is to consider each value independently. `Rnd(10)` will return a random value between 0 and 10 - let us imagine this returns `6` so that we can see what that does. In this case, `1000 * Rnd(10)` becomes `1000 * 6`, as the value **returned** by `Rnd(10)` was `6`. This is then evaluated, and `Delay` will be passed the argument `6000`, causing it to delay for 6 seconds.

## Method Calls Up Close

Review the following images to explore how method calls work within the computer.

<MySwiper client:only height="" images={sliderImages}></MySwiper>

:::note[Summary]

- A method call is an **instruction** that commands the computer to run the code in a method.
- Use the name to identify the [Method](../02-method) to run.
- Data values passed to the method are called **arguments**. These are put between parentheses after the method name.
- When the method’s task is complete the program continues with the next instruction after the method call.

:::
