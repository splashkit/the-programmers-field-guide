---
title: Replying
sidebar:
  label: " - Replying"
---
import { Accordion, AccordionItem } from 'accessible-astro-components'
import NoCopy from '/src/components/NoCopy.astro'
import Carousel from '/src/components/Carousel.astro'
import { Steps } from '@astrojs/starlight/components';

We've been able to output some messages, and have the user type some text. Now let's use what they typed to adjust our messages.

<Steps>
1. Let's first try just echoing what the user typed straight back to them. We know that `write_line(...)` can take a string and write it to the console, and we know that `read_line()` _returns_ a string. So what we can do, is pass the result of `read_line()` into `write_line(...)`.

    This can be done the same way we might call `write_line("My text!")` - `"My text!"` is just `read_line()` instead.
    <Accordion>
      <AccordionItem header="Echo what the user types">

    ```c++ {15}
    #include "splashkit.h"

    int main()
    {
        write_line("Welcome to the very basic bot experience!");
        write_line("Please answer using single words :)");
        delay(200);
        write_line("----------------------------------------");
        delay(200);
        write_line();

        delay(200);
        write_line("Bot: Hello! What's your name?");
        write("> ");
        write_line(read_line());

        return 0;
    }
    ```
      </AccordionItem>
    </Accordion>

    <Carousel>
        <div>
            Let's make sure we understand the order of what's happening here.
            ```c++ {1}
                ...
                write("> ");
                write_line(read_line());
                ...
            ```
            ```sh
                ...
            ```
        </div>
        <div>
            1. The `> ` is written to the terminal.
            ```c++ "write(\"> \")" {2}
                ...
                write("> ");
                write_line(read_line());
                ...
            ```
            ```sh
                ...
                >
            ```
        </div>
        <div>
            2. In order to call `write_line`, _first_ the result of `read_line()` is needed. So `read_line()` is called first.
            ```c++ "read_line()" {3}
                ...
                write("> ");
                write_line(read_line());
                ...
            ```
            ```sh
                ...
                > _
            ```
        </div>
        <div>
            3. The user can now type, with their text appearing at the end of the `> ` we wrote before.
            ```c++ "read_line()" {3}
                ...
                write("> ");
                write_line(read_line());
                ...
            ```
            ```sh
                ...
                > Sean_
            ```
        </div>
        <div>
            4. Once the user presses `Enter`, _now_ the text they typed is _returned_ from `read_line()`
            ```c++ "write_line(read_line())" {"                   'Sean'   ":3-4}
                ...
                write("> ");

                write_line(read_line());
                ...
            ```
            ```sh
                ...
                > Sean
                _
            ```
        </div>
        <div>
            5.  Now `write_line(...)` is called, with the text that the user typed as its argument.
            ```c++ "write_line(read_line())" {"                   'Sean'   ":3-4}
                ...
                write("> ");

                write_line(read_line());
                ...
            ```
            ```sh
                ...
                > Sean
                Sean
            ```
        </div>
    </Carousel>

2. Now let's greet our user! Here's an important thing to know now - strings can be combined together by using the `+` operator. For instance, `"Hello " + "Sean"` results in the string `"Hello Sean"`.

    We can use the same principle here to combine pre-written text with the result from `read_line()` - remember, we can treat `read_line()` exactly as if it were the text it returns. See if you can get it to greet the user with something like `"Bot: Hi <user>, nice to meet you!"`

    <Accordion>
      <AccordionItem header="Greeting the user">

    ```c++ {15}
    #include "splashkit.h"

    int main()
    {
        write_line("Welcome to the very basic bot experience!");
        write_line("Please answer using single words :)");
        delay(200);
        write_line("----------------------------------------");
        delay(200);
        write_line();

        delay(200);
        write_line("Bot: Hello! What's your name?");
        write("> ");
        write_line("Bot: Hi " + read_line() + ", nice to meet you!");

        return 0;
    }
    ```
      </AccordionItem>
    </Accordion>

3. Once you've got that working, you can re-use the exact same code pattern for the rest of the messages. Here I've added one more, but feel free to add as many as you want!

    <Accordion>
      <AccordionItem header="Greeting the user">

    ```c++ {17-20}
    #include "splashkit.h"

    int main()
    {
        write_line("Welcome to the very basic bot experience!");
        write_line("Please answer using single words :)");
        delay(200);
        write_line("----------------------------------------");
        delay(200);
        write_line();

        delay(200);
        write_line("Bot: Hello! What's your name?");
        write("> ");
        write_line("Bot: Hi " + read_line() + ", nice to meet you!");

        delay(200);
        write_line("Bot: So, do you like cats?");
        write("> ");
        write_line("Bot: " + read_line() + "!?");

        return 0;
    }
    ```
      </AccordionItem>
    </Accordion>

4. As one last touch, let's try adjusting the user's text to give our bot some more personality. Right now we always use the user's text exactly as they wrote it. But, for instance in my bot's last message, I want them to seem surprised and be using uppercase. We can use `to_uppercase(input)` or `to_lowercase(input)` to adjust the case - try passing your `read_line()` through one of those.

    <Accordion>
      <AccordionItem header="Surprised reaction">

    ```c++ {20}
    #include "splashkit.h"

    int main()
    {
        write_line("Welcome to the very basic bot experience!");
        write_line("Please answer using single words :)");
        delay(200);
        write_line("----------------------------------------");
        delay(200);
        write_line();

        delay(200);
        write_line("Bot: Hello! What's your name?");
        write("> ");
        write_line("Bot: Hi " + read_line() + ", nice to meet you!");

        delay(200);
        write_line("Bot: So, do you like cats?");
        write("> ");
        write_line("Bot: " + to_uppercase(read_line()) + "!?");

        return 0;
    }
    ```
      </AccordionItem>
    </Accordion>



    <Carousel>
        <div>
            Let's make sure we understand the order of what's happening here.
            ```c++ {1}
                ...
                write("> ");
                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
            ```
        </div>
        <div>
            1. The `> ` is written to the terminal.
            ```c++ "write(\"> \")" {2}
                ...
                write("> ");
                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                >
            ```
        </div>
        <div>
            2. In order to call `write_line`, _first_ the result of `"Bot: " + to_uppercase()` is needed. _But_, to call `to_uppercase`, first we need the result of `read_line()`! So `read_line()` is called first.
            ```c++ "read_line()" {3}
                ...
                write("> ");
                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                > _
            ```
        </div>
        <div>
            3. The user can now type, with their text appearing at the end of the `> ` we wrote before.
            ```c++ "read_line()" {3}
                ...
                write("> ");
                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                > yes_
            ```
        </div>
        <div>
            4. Once the user presses `Enter`, _now_ the text they typed is _returned_ from `read_line()`
            ```c++ "read_line()" {"                                          'yes'            ":3-4}
                ...
                write("> ");

                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                > yes
                _
            ```
        </div>
        <div>
            5.  Now `to_uppercase(...)` is called, with the text that the user typed as its argument. It returns the uppercased output.
            ```c++ "to_uppercase(read_line())" {"                                  'YES'                    ":3-4}
                ...
                write("> ");

                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                > yes
                _
            ```
        </div>
        <div>
            6.  `to_uppercase(...)` returns now with "YES", and this is used in the surrounding _expression_.
            ```c++ '"Bot: " + to_uppercase(read_line()) + "!?"' {"                                 'Bot: YES!?'            ":3-4}
                ...
                write("> ");

                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                > yes
                _
            ```
        </div>
        <div>
            7.  Finally `write_line(...)` is called, with the finished message as its argument.
            ```c++ 'write_line("Bot: " + to_uppercase(read_line()) + "!?");' {3}
                ...
                write("> ");
                write_line("Bot: " + to_uppercase(read_line()) + "!?");
                ...
            ```
            ```sh
                ...
                > yes
                Bot: YES!?
            ```
        </div>
    </Carousel>
</Steps>

Nice work! Hopefully now you feel more confident in understanding the sequence in which code is executed, and the sorts of terminal functions and procedures you can use. You may have also already begun to notice some gaps in what we can express through code currently, particularly:
 - There's no way for our chatbot to _remember_ anything, since we use each value from `read_line()` immediately and don't store it anywhere.
 - The order we have to write our code is a bit odd - it would be nicer to call `read_line()` on a line _before_ the `write_line` the result is used in - again, we'll need somewhere to store the value temporarily before we use it.

For now we'll continue working within these limitations in-order to focus on _sequence_, but the concepts we cover in the next chapter will solve these issues.
