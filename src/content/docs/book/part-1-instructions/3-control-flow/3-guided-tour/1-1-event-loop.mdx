---
title: Looping
sidebar:
    label: " - Looping"
---
import { Accordion, AccordionItem } from 'accessible-astro-components'

Compile and run the program. What happens? The program starts, a window appears, and it closes after a short delay. How can we change the program so that it only closes when the user decides?

We can achieve this using a loop. The loop will repeat while the user has *not* asked to quit (which you can check with the `quit_requested` function). This will require us to call `process_events` inside the loop so that SplashKit can detect if the user has closed the window.

Have a go at adding this loop yourself. This should start after the window is opened, and include the code to clear the screen and fill the circle. You can remove the `delay` code, as the loop will control the duration of the program.

<Accordion>
    <AccordionItem header="Code with loop">

    ```c++ {9-10,15-16}
    #include "splashkit.h"

    const int PLAYER_RADIUS = 50;

    int main()
    {
        open_window("Circle Moving", 1280, 720);

        while(!quit_requested())
        {
            clear_screen(COLOR_WHITE);
            fill_circle(COLOR_TURQUOISE, 640, 360, PLAYER_RADIUS);
            refresh_screen(60);

            process_events();
        }
    }
    ```

    </AccordionItem>
</Accordion>

:::tip

Remember to **indent** the code within the `{ ... }`.
This helps to make your code more readable, as it's easier to see the control flow.

:::

Compile and run the program. It should now stay around for as long as you want.

Think about what is happening as your program executes. The computer is running through the loop again and again. Each loop it redraws the screen, records what events happened, and then the loop condition checks if the user has quit. It's doing this as fast as it can!

It looks like nothing is happening, so it can be hard to believe. To get a sense of how quickly the loop is executing, add a `write_line("here");` call inside the loop, then compile and run it again. Watch the terminal output, and you will see the message written over and over.

Now that we have a loop we can add code to check what events have occurred and update the program in response.

:::note

The while loop is letting you repeat some code based on a condition. In an interactive program, this loop is called the **event loop** as it allows you to watch for, and react to, events.

:::

Now we have the loop going, let's get the player moving. At the moment, the circle's position is fixed. Let's change this to use a variable for the x coordinate of the player.

Add a new `player_x` variable, initialise this to 640, and use the variable as the value for the x coordinate when filling the circle. Using a variable will allow us to change the value.

<Accordion>
  <AccordionItem header="Code with player position variable">

    ```c++ {7,14}
    #include "splashkit.h"

    const int PLAYER_RADIUS = 50;

    int main()
    {
        int player_x = 640;

        open_window("Circle Moving", 1280, 720);

        while( ! quit_requested() )
        {
            clear_screen(COLOR_WHITE);
            fill_circle(COLOR_TURQUOISE, player_x, 360, PLAYER_RADIUS);
            refresh_screen(60);

            process_events();
        }

    }
    ```
  </AccordionItem>
</Accordion>

Run the program and make sure that it is still working.

Now that we have a variable for the player's position, we can change this every loop. This should make the circle appear to move!

Create a `PLAYER_SPEED` constant with the value 3. Add this to the `player_x` variable within the loop.

<Accordion>
  <AccordionItem header="Code with player moving">

    ```c++ {4,18}
    #include "splashkit.h"

    const int PLAYER_RADIUS = 50;
    const int PLAYER_SPEED = 3;

    int player_x = 640;

    open_window("Circle Moving", 1280, 720);

    while( ! quit_requested() )
    {
        clear_screen(COLOR_WHITE);
        fill_circle(COLOR_TURQUOISE, player_x, 360, PLAYER_RADIUS);
        refresh_screen(60);

        process_events();

        player_x += PLAYER_SPEED; // this is a short-hand way of writing player_x = player_x + PLAYER_SPEED;
    }
    ```
    </AccordionItem>
</Accordion>

Compile and run the program. What happens?

Update the code to move the player in the other direction. Then, have a go at adding the code to move the player vertically as well. This will need a `player_y` variable.
