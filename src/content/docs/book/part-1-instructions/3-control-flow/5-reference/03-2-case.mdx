---
title: Case Statement
sidebar: 
  label: " - Case Statement"
---
import { Aside } from '@astrojs/starlight/components';
import MySwiper from '../../../../../../components/react/myswiper.jsx'

import caseStatementSlide01 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide1.png';
import caseStatementSlide02 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide2.png';
import caseStatementSlide03 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide3.png';
import caseStatementSlide04 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide4.png';
import caseStatementSlide05 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide5.png';
import caseStatementSlide06 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide6.png';
import caseStatementSlide07 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide7.png';
import caseStatementSlide08 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide8.png';
import caseStatementSlide09 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide9.png';
import caseStatementSlide10 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide10.png';
import caseStatementSlide11 from './images/control-flow-statements-in-depth/control-flow-case-statement/Slide11.png';

export const sliderImagesCaseStatement = [
  {
    src: caseStatementSlide01.src,
    altText: "",
    tipStart: 1,
    tips: [
      "Lines 1 - 4 get the user's input (in this case we'll say the user entered '2', which is the option for C#), converts it to an integer, and stores it in the variable 'language' on the stack.",
      "The program counter is incremented to 5, ready to run the 'switch' statement."
    ]
  },
  {
    src: caseStatementSlide02.src,
    altText: "On line 5, the switch statement asks the computer to compare the value in the variable 'language' (2), to the value of all the case statements in it's scope (which is defined by the opening and closing braces of the switch statement) until a match is found. It increments the program counter to point to the first case statement on line 7.",
    tipStart: 2,
    tips: [
      "On line 5, the switch statement starts to compare the value in the variable 'language' to the value of all the cases until a match is found.",
    ]
  },
  {
    src: caseStatementSlide03.src,
    altText: "Line 7 encounters the first case statement, and compares the value of 'language' (2) to the value of the case statement (1). The comparison is false (2 != 1). So the program counter jumps to the next 'case' statement (line 10).",
    tipStart: 3,
    tips: [
      "The first case is on line 7.",
      "This compares the loaded value (2) to the value of the case (1).",
      "The comparison is <span class='booleanFalse'>false</span> (2 != 1), so the program counter jumps to the next case (line 10)."
    ]
  },
  {
    src: caseStatementSlide04.src,
    altText: "On line 10 the comparison is 'true' (2 == 2). The program counter then increments to line 11.",
    tipStart: 4,
    tips: [
      "On line 10 the comparison is <span class='booleanTrue'>true</span> (2 == 2).",
      "The sequence starts running here.",
      "The program counter then increments to line 11."
    ]
  },
  {
    src: caseStatementSlide05.src,
    altText: "Notice that the case statement on line 11, lies directly below the case statement on line 10. When case statements are grouped together like this, as soon as any 'case' in the group evaluates to 'true', the remaining 'case' statements in the group are skipped to execute the code associated with this group of case statements. The program counter therefore increments to line 12 ",
    tipStart: 5,
    tips: [
      "Line 11 is another case. Because the switch statement has already matched a case no comparison is made.",
      "The computer drops through the case, meaning that the sequence continues.",
      "You can group cases like this - as soon as any case in the group evaluates to 'true', the code associated with the group is run.",
      "The program counter therefore increments to line 12."
    ]
  },
  {
    src: caseStatementSlide06.src,
    altText: "At line 12 we output the message to the terminal. The program counter is incremented to line 13.",
    tipStart: 6,
    tips: [
      "At line 12 we output a message to the terminal.",
      "The program counter is incremented to line 13."
    ]
  },
  {
    src: caseStatementSlide07.src,
    altText: "At line 13 we encounter a 'break' statement which terminates the code associated with the 'true' case block. The 'break statement will jump to the end of the 'switch' statement (line 16), and the program counter is incremented to point to the next line of code (line 17)",
    tipStart: 7,
    tips: [
      "The 'break' statement on line 13 jumps to the end of the case statement.",
      "This sets the program counter to run line 17 - the first instruction after the case statement.",
      "Without a break, control would flow into the 'default' code that follows."
    ]
  },
  {
    src: caseStatementSlide08.src,
    altText: "At line 17 the message is output to the terminal. The program counter increases, and the program ends.",
    tipStart: 8,
    tips: [
      "At line 17 a message is output to the terminal.",
      "The program counter increases, and the program ends."
    ]
  },
  {
    src: caseStatementSlide09.src,
    altText: "This time the user has input 4",
    tipStart: 9,
    tips: [
      "Let's rewind back to line 4, this time pretending that the user has input 4 (for \"Other\")."
    ]
  },
  {
    src: caseStatementSlide10.src,
    altText: "Now the switch comparison (line 5) to the case statement values (lines 7, 10 and 11) all evaluate to 'false'. So the program is incremented to line 14 (the 'default' statement)",
    tipStart: 10,
    tips: [
      "Now the switch comparison (line 5) to the case statement values (lines 7, 10 and 11) all evaluate to <span class='booleanFalse'>false</span>.",
      "So, the program counter is set to line 14, the 'default' case."
    ]
  },
  {
    src: caseStatementSlide11.src,
    altText: "Lines 14 and 15 executes the block of code associated with 'default' and prints a message to the screen. The switch statement ends when it encounters the closing brace. The program counter is incremented to line 17, and the final message is output to the terminal. The program counter increments a final time to end.",
    tipStart: 11,
    tips: [
      "Lines 14 and 15 executes the block of code associated with the default case, printing a message to the terminal.",
      "The switch statement ends when it encounters the closing brace on line 16.",
      "The program counter is incremented to line 17, and the final message is output to the terminal."
    ]
  }
];

<Aside type="note" title="In Brief">
  ![Switch illustration code](./images/switch-code.png)

  #### Case statements...

  - will select the path where the case matches the value in the switch
  - do not have visible conditions, but they are behind the scenes.
  - use a condition that checks if the switch's value equals each case.

  :::tip

  You will use the if statement much more than switch/case, but switch/case can be useful when you have a known list of values to choose between.

  :::
</Aside>

The case statement is the second kind of branching statement. It allows you to create paths that execute code based to value of an expression. This allows one case statement to handle many alternative paths.

![Case statement selectively runs multiple branches of code](./images/statement-case.png "Case statement selectively runs multiple branches of code")

{/*TODO: add dots background*/}

## `Case` Statement -- when, why, and how

The case statement is a more specialised way of branching in code, so it tends to be used less frequently than the [if statement](/book/part-1-instructions/3-control-flow/5-reference/03-1-if). To use a case statement you need to have a single expression. Each branch of the case statement has a value it tests the expression against, and only executes if the two values match.

Looking back at the [example](/book/part-1-instructions/3-control-flow/5-reference/03-1-if#multiple-if-statements-combined) we gave for using multiple if statements, we could convert this code to a single case statement. Each branch would test if the language entered by the user matched a fixed value. When the language is "C#", our case statement would run one block; when it is "C" or "C++" our case statement would run another block. There are no limits to the number of cases a single case statement can have, as long as every branch has a unique value to test for.

:::tip[If or case?]
You can code any case statement as a series of if statements. However, the case statement is a bit neater and generally preferred if possible. The if statement is the more flexible of the branching statements, so you will use it for most things.
:::

## In C++

:::tip[Syntax]
The following diagram shows the C++ syntax for a case statement.

![The case statement showing switch, then an expression, and a list of cases](./images/case-statement.png)
:::

The syntax for the case statement in C++ uses the keyword **switch** followed by the expression to test.
In C++, case statements are limited to only testing integers and single characters. Any integral [types](/book/part-1-instructions/1-sequence/5-reference/15-type/) such as `int`, `bool`, and `char`  are valid, however `double` and `string` are not.
Within the curly braces you then have a list of cases.
Each case has a value to match followed by a colon (`:`) and a list of statements.
The final case is labelled with the `default` keyword.
This optional branch contains code you want to execute if none of the other cases matched.

When a case is matched (i.e., the value of the expression matches the value of the case), the computer jumps to the first statement within that case and runs the code in sequence from that point.
This includes the code in the following cases!
You might be wondering why -- surely when the computer encounters the next `case` it will see that the values don't match and not run that branch?
It might seem unintuitive, but once a case has been matched, the computer basically just ignores all other "case" tests in the same case statement.
This allows the computer to "drop through" into other cases, which can be used to combine multiple branches.

If you want the computer to skip to the end of a case statement, you must use the [break](/book/part-1-instructions/3-control-flow/5-reference/05-1-break) statement.
Break is used to jump to the end of the case statement, ensuring that you skip over paths you do not want to run.
We will explore the break statement in more detail soon, but for now you just need to know that it will tell the computer to jump to the end of a case statement, and without it the code from the following cases will be executed.

## How does `case` work?

The case statement works in a very similar way to the if statement we worked through previously. The following code will achieve a similar output as the [last example](/book/part-1-instructions/3-control-flow/5-reference/03-1-if#multiple-if-statements-combined) from the if statement page.
It has been adjusted so that the user chooses from a numbered list of languages, by entering its number - remember, case statements in C++ cannot compare strings.

In this example, the value we want to check is whatever the user entered, which has been stored in the `language` variable.
So, `language` goes in parentheses right after the `switch` keyword.
 Within the body of the case statement you then have the separate cases you want to match.

Notice that we have used the [break](/book/part-1-instructions/3-control-flow/5-reference/05-1-break) statement at the end of the "C++" and "C" branches to indicate the end of the instructions for these individual cases. Also notice how we intentionally do not use a break statement in the "C#" case. This means that when the "C#" path is matched, the control will flow through into the same set of statements that exist for the "C" branch, and we have avoided needing to repeat the same code in both branches.

```c++
#include "splashkit.h"

int main()
{
    int language;

    write_line("What language do you use?");
    write_line("1. C++");
    write_line("2. C#");
    write_line("3. C");
    write_line("4. Other");
    write("(Please enter a number): ");
    language = to_integer(read_line());

    switch (language)
    {
        case 1: // C++
            write_line("C++ is a great language.");
            break;
        case 2: // C#
        case 3: // C
            write_line("These are fine languages.");
            break;
        default: // Other/Any other number
            write_line("Well... good luck with that!");
            break;
    }

    write_line("Great chat!");
}
```

Use the following images to see how this code runs.

<MySwiper client:only height="" images={sliderImagesCaseStatement}></MySwiper>

:::tip[Attention]
Allowing the `break` statement to be omitted in C++ makes `switch` statements more flexible -- for instance it allows us to intentionally fall through multiple `case` labels, as in the example above. However we also need to be careful.

If we forget to include a `break` where we _do_ want it, the compiler won't warn us -- we'll unexpectedly fall through multiple of the cases.
:::

:::note[Summary]

- The case statement is a kind of **instruction**. It allows you to command the computer to select a path based on the value of an expression.
- Each path within the case statement has a value. The computer compares the case statement's expression to each path's value to determine which path to take.
- Older languages like C++ limit the case statement to work only with integers and individual characters.
- The case statement has one entry point, multiple paths, and then one exit point.

:::
